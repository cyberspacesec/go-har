package har

import (
	"encoding/json"
	"os"
	"strconv"
	"strings"
	"time"
)

// 使用指针类型避免空值占用空间
// 使用枚举类型减少字符串内存使用
// 使用map优化查找性能

// HTTPMethod HTTP方法类型
type HTTPMethod uint8

const (
	MethodUnknown HTTPMethod = iota
	MethodGET
	MethodPOST
	MethodPUT
	MethodDELETE
	MethodHEAD
	MethodOPTIONS
	MethodPATCH
	MethodCONNECT
	MethodTRACE
)

var methodToString = map[HTTPMethod]string{
	MethodUnknown: "UNKNOWN",
	MethodGET:     "GET",
	MethodPOST:    "POST",
	MethodPUT:     "PUT",
	MethodDELETE:  "DELETE",
	MethodHEAD:    "HEAD",
	MethodOPTIONS: "OPTIONS",
	MethodPATCH:   "PATCH",
	MethodCONNECT: "CONNECT",
	MethodTRACE:   "TRACE",
}

var stringToMethod = map[string]HTTPMethod{
	"GET":     MethodGET,
	"POST":    MethodPOST,
	"PUT":     MethodPUT,
	"DELETE":  MethodDELETE,
	"HEAD":    MethodHEAD,
	"OPTIONS": MethodOPTIONS,
	"PATCH":   MethodPATCH,
	"CONNECT": MethodCONNECT,
	"TRACE":   MethodTRACE,
}

// String 将HTTPMethod转换为字符串
func (m HTTPMethod) String() string {
	if s, ok := methodToString[m]; ok {
		return s
	}
	return "UNKNOWN"
}

// ParseMethod 从字符串解析方法
func ParseMethod(s string) HTTPMethod {
	if m, ok := stringToMethod[strings.ToUpper(s)]; ok {
		return m
	}
	return MethodUnknown
}

// MarshalJSON 自定义HTTPMethod的JSON序列化
func (m HTTPMethod) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.String())
}

// UnmarshalJSON 自定义HTTPMethod的JSON反序列化
func (m *HTTPMethod) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*m = ParseMethod(s)
	return nil
}

// OptimizedEntries 内存优化的条目结构
type OptimizedEntries struct {
	StartedDateTime time.Time `json:"startedDateTime"`
	Time            float64   `json:"time"`

	// 使用优化的请求结构
	Request struct {
		Method      HTTPMethod        `json:"method"`
		URL         string            `json:"url"`
		HTTPVersion string            `json:"httpVersion,omitempty"`
		Headers     map[string]string `json:"headers,omitempty"`
		Cookies     []Cookie          `json:"cookies,omitempty"`
		QueryString map[string]string `json:"queryString,omitempty"`
		HeadersSize *int              `json:"headersSize,omitempty"`
		BodySize    *int              `json:"bodySize,omitempty"`
		PostData    *PostData         `json:"postData,omitempty"`
	} `json:"request"`

	// 使用优化的响应结构
	Response struct {
		Status       int               `json:"status"`
		StatusText   string            `json:"statusText,omitempty"`
		HTTPVersion  string            `json:"httpVersion,omitempty"`
		Headers      map[string]string `json:"headers,omitempty"`
		Cookies      []Cookie          `json:"cookies,omitempty"`
		Content      *OptimizedContent `json:"content,omitempty"`
		RedirectURL  string            `json:"redirectURL,omitempty"`
		HeadersSize  *int              `json:"headersSize,omitempty"`
		BodySize     *int              `json:"bodySize,omitempty"`
		TransferSize *int              `json:"_transferSize,omitempty"`
	} `json:"response"`

	// 可选字段使用指针，减少内存占用
	Timings  *OptimizedTimings `json:"timings,omitempty"`
	Cache    *Cache            `json:"cache,omitempty"`
	Pageref  *string           `json:"pageref,omitempty"`
	ServerIP *string           `json:"serverIPAddress,omitempty"` // 重命名以更短
}

// OptimizedContent 内存优化的内容结构
type OptimizedContent struct {
	Size     int     `json:"size"`
	MimeType string  `json:"mimeType"`
	Text     *string `json:"text,omitempty"`
	Encoding *string `json:"encoding,omitempty"`
}

// PostData 请求的POST数据
type PostData struct {
	MimeType string          `json:"mimeType"`
	Params   []PostDataParam `json:"params,omitempty"`
	Text     *string         `json:"text,omitempty"`
}

// PostDataParam POST参数
type PostDataParam struct {
	Name        string  `json:"name"`
	Value       *string `json:"value,omitempty"`
	FileName    *string `json:"fileName,omitempty"`
	ContentType *string `json:"contentType,omitempty"`
}

// OptimizedHar 内存优化的HAR对象
type OptimizedHar struct {
	Log struct {
		Version string             `json:"version"`
		Creator Creator            `json:"creator"`
		Pages   []Pages            `json:"pages,omitempty"`
		Entries []OptimizedEntries `json:"entries"`
	} `json:"log"`
}

// fromHeaders 将标准Headers切片转换为map
func fromHeaders(headers []Headers) map[string]string {
	if len(headers) == 0 {
		return nil
	}

	result := make(map[string]string, len(headers))
	for _, h := range headers {
		result[h.Name] = h.Value
	}
	return result
}

// toHeaders 将map转换为标准Headers切片
func toHeaders(headerMap map[string]string) []Headers {
	if len(headerMap) == 0 {
		return nil
	}

	result := make([]Headers, 0, len(headerMap))
	for name, value := range headerMap {
		result = append(result, Headers{
			Name:  name,
			Value: value,
		})
	}
	return result
}

// ParseQueryString 解析URL中的查询参数
func ParseQueryString(url string) map[string]string {
	parts := strings.Split(url, "?")
	if len(parts) < 2 {
		return nil
	}

	queryParts := strings.Split(parts[1], "&")
	result := make(map[string]string, len(queryParts))

	for _, part := range queryParts {
		keyValue := strings.SplitN(part, "=", 2)
		if len(keyValue) == 2 {
			result[keyValue[0]] = keyValue[1]
		} else if len(keyValue) == 1 {
			result[keyValue[0]] = ""
		}
	}

	return result
}

// FromStandardHar 将标准HAR对象转换为内存优化的HAR对象
func FromStandardHar(har *Har) *OptimizedHar {
	result := &OptimizedHar{}
	result.Log.Version = har.Log.Version
	result.Log.Creator = har.Log.Creator
	result.Log.Pages = har.Log.Pages

	// 预分配空间，避免动态扩容
	result.Log.Entries = make([]OptimizedEntries, len(har.Log.Entries))

	for i, entry := range har.Log.Entries {
		optimizedEntry := OptimizedEntries{
			StartedDateTime: entry.StartedDateTime,
			Time:            entry.Time,
		}

		// 转换请求
		optimizedEntry.Request.Method = ParseMethod(entry.Request.Method)
		optimizedEntry.Request.URL = entry.Request.URL
		optimizedEntry.Request.HTTPVersion = entry.Request.HTTPVersion
		optimizedEntry.Request.Headers = fromHeaders(entry.Request.Headers)
		optimizedEntry.Request.Cookies = entry.Request.Cookies
		optimizedEntry.Request.QueryString = ParseQueryString(entry.Request.URL)

		if entry.Request.HeadersSize != 0 {
			size := entry.Request.HeadersSize
			optimizedEntry.Request.HeadersSize = &size
		}

		if entry.Request.BodySize != 0 {
			size := entry.Request.BodySize
			optimizedEntry.Request.BodySize = &size
		}

		// 转换响应
		optimizedEntry.Response.Status = entry.Response.Status
		optimizedEntry.Response.StatusText = entry.Response.StatusText
		optimizedEntry.Response.HTTPVersion = entry.Response.HTTPVersion
		optimizedEntry.Response.Headers = fromHeaders(entry.Response.Headers)
		optimizedEntry.Response.Cookies = entry.Response.Cookies
		optimizedEntry.Response.RedirectURL = entry.Response.RedirectURL

		// 复制内容
		optimizedEntry.Response.Content = &OptimizedContent{
			Size:     entry.Response.Content.Size,
			MimeType: entry.Response.Content.MimeType,
		}

		if entry.Response.HeadersSize != 0 {
			size := entry.Response.HeadersSize
			optimizedEntry.Response.HeadersSize = &size
		}

		if entry.Response.BodySize != 0 {
			size := entry.Response.BodySize
			optimizedEntry.Response.BodySize = &size
		}

		if entry.Response.TransferSize != 0 {
			size := entry.Response.TransferSize
			optimizedEntry.Response.TransferSize = &size
		}

		// 转换计时信息
		standardTimings := Timings{}

		// 转换非空指针值
		if entry.Timings.Blocked != nil {
			standardTimings.Blocked = *entry.Timings.Blocked
		}
		if entry.Timings.DNS != nil {
			standardTimings.DNS = *entry.Timings.DNS
		}
		if entry.Timings.Connect != nil {
			standardTimings.Connect = *entry.Timings.Connect
		}
		if entry.Timings.Send != nil {
			standardTimings.Send = *entry.Timings.Send
		}
		if entry.Timings.Wait != nil {
			standardTimings.Wait = *entry.Timings.Wait
		}
		if entry.Timings.Receive != nil {
			standardTimings.Receive = *entry.Timings.Receive
		}
		if entry.Timings.Ssl != nil {
			standardTimings.Ssl = *entry.Timings.Ssl
		}
		if entry.Timings.BlockedQueueing != nil {
			standardTimings.BlockedQueueing = *entry.Timings.BlockedQueueing
		}
		if entry.Timings.BlockedProxy != nil {
			standardTimings.BlockedProxy = *entry.Timings.BlockedProxy
		}

		optimizedEntry.Timings = &standardTimings

		if entry.Cache.Comment != "" || entry.Cache.BeforeRequest != (BeforeRequest{}) || entry.Cache.AfterRequest != (AfterRequest{}) {
			optimizedEntry.Cache = &entry.Cache
		}

		if entry.Pageref != "" {
			optimizedEntry.Pageref = &entry.Pageref
		}

		if entry.ServerIPAddress != "" {
			optimizedEntry.ServerIP = &entry.ServerIPAddress
		}

		result.Log.Entries[i] = optimizedEntry
	}

	return result
}

// ToStandardHar 将内存优化的HAR对象转换为标准HAR对象
func (oh *OptimizedHar) ToStandardHar() *Har {
	result := &Har{}
	result.Log.Version = oh.Log.Version
	result.Log.Creator = oh.Log.Creator
	result.Log.Pages = oh.Log.Pages

	// 预分配空间，避免动态扩容
	result.Log.Entries = make([]Entries, len(oh.Log.Entries))

	for i, entry := range oh.Log.Entries {
		// 创建标准条目
		standardEntry := Entries{
			StartedDateTime: entry.StartedDateTime,
			Time:            entry.Time,
		}

		// 转换请求
		standardEntry.Request.Method = entry.Request.Method.String()
		standardEntry.Request.URL = entry.Request.URL
		standardEntry.Request.HTTPVersion = entry.Request.HTTPVersion
		standardEntry.Request.Headers = toHeaders(entry.Request.Headers)
		standardEntry.Request.Cookies = entry.Request.Cookies

		if entry.Request.HeadersSize != nil {
			standardEntry.Request.HeadersSize = *entry.Request.HeadersSize
		}

		if entry.Request.BodySize != nil {
			standardEntry.Request.BodySize = *entry.Request.BodySize
		}

		// 转换响应
		standardEntry.Response.Status = entry.Response.Status
		standardEntry.Response.StatusText = entry.Response.StatusText
		standardEntry.Response.HTTPVersion = entry.Response.HTTPVersion
		standardEntry.Response.Headers = toHeaders(entry.Response.Headers)
		standardEntry.Response.Cookies = entry.Response.Cookies
		standardEntry.Response.RedirectURL = entry.Response.RedirectURL

		// 复制内容
		if entry.Response.Content != nil {
			standardEntry.Response.Content.Size = entry.Response.Content.Size
			standardEntry.Response.Content.MimeType = entry.Response.Content.MimeType
		}

		if entry.Response.HeadersSize != nil {
			standardEntry.Response.HeadersSize = *entry.Response.HeadersSize
		}

		if entry.Response.BodySize != nil {
			standardEntry.Response.BodySize = *entry.Response.BodySize
		}

		if entry.Response.TransferSize != nil {
			standardEntry.Response.TransferSize = *entry.Response.TransferSize
		}

		// 转换可选字段
		// 转换计时信息
		standardEntry.Timings = Timings{}

		// 转换非空指针值
		if entry.Timings.Blocked != nil {
			standardEntry.Timings.Blocked = *entry.Timings.Blocked
		}
		if entry.Timings.DNS != nil {
			standardEntry.Timings.DNS = *entry.Timings.DNS
		}
		if entry.Timings.Connect != nil {
			standardEntry.Timings.Connect = *entry.Timings.Connect
		}
		if entry.Timings.Send != nil {
			standardEntry.Timings.Send = *entry.Timings.Send
		}
		if entry.Timings.Wait != nil {
			standardEntry.Timings.Wait = *entry.Timings.Wait
		}
		if entry.Timings.Receive != nil {
			standardEntry.Timings.Receive = *entry.Timings.Receive
		}
		if entry.Timings.Ssl != nil {
			standardEntry.Timings.Ssl = *entry.Timings.Ssl
		}
		if entry.Timings.BlockedQueueing != nil {
			standardEntry.Timings.BlockedQueueing = *entry.Timings.BlockedQueueing
		}
		if entry.Timings.BlockedProxy != nil {
			standardEntry.Timings.BlockedProxy = *entry.Timings.BlockedProxy
		}

		if entry.Cache != nil {
			standardEntry.Cache = *entry.Cache
		}

		if entry.Pageref != nil {
			standardEntry.Pageref = *entry.Pageref
		}

		if entry.ServerIP != nil {
			standardEntry.ServerIPAddress = *entry.ServerIP
		}

		result.Log.Entries[i] = standardEntry
	}

	return result
}

// ParseHarOptimized 使用内存优化的结构解析HAR内容
func ParseHarOptimized(harFileBytes []byte) (*OptimizedHar, error) {
	har := new(OptimizedHar)
	err := json.Unmarshal(harFileBytes, har)
	if err != nil {
		return nil, WrapJSONUnmarshalError(err)
	}
	return har, nil
}

// ParseHarFileOptimized 使用内存优化的结构解析HAR文件
func ParseHarFileOptimized(harFilePath string) (*OptimizedHar, error) {
	harFileBytes, err := os.ReadFile(harFilePath)
	if err != nil {
		return nil, NewFileSystemError("无法读取HAR文件", err)
	}
	return ParseHarOptimized(harFileBytes)
}

// GetRequestHeadersSize 计算请求头的大小
func (entry *OptimizedEntries) GetRequestHeadersSize() int {
	if entry.Request.HeadersSize != nil {
		return *entry.Request.HeadersSize
	}

	// 估算请求头大小
	size := len(entry.Request.Method.String()) + len(entry.Request.URL) + len(entry.Request.HTTPVersion) + 4 // 请求行

	for name, value := range entry.Request.Headers {
		size += len(name) + len(value) + 4 // 名称 + ": " + 值 + "\r\n"
	}

	return size
}

// GetResponseHeadersSize 计算响应头的大小
func (entry *OptimizedEntries) GetResponseHeadersSize() int {
	if entry.Response.HeadersSize != nil {
		return *entry.Response.HeadersSize
	}

	// 估算响应头大小
	size := len(entry.Response.HTTPVersion) + len(strconv.Itoa(entry.Response.Status)) + len(entry.Response.StatusText) + 4 // 状态行

	for name, value := range entry.Response.Headers {
		size += len(name) + len(value) + 4 // 名称 + ": " + 值 + "\r\n"
	}

	return size
}

// SearchByURL 在优化的HAR中按URL搜索
func (oh *OptimizedHar) SearchByURL(pattern string) []OptimizedEntries {
	var results []OptimizedEntries

	for _, entry := range oh.Log.Entries {
		if strings.Contains(entry.Request.URL, pattern) {
			results = append(results, entry)
		}
	}

	return results
}

// SearchByMethod 在优化的HAR中按方法搜索
func (oh *OptimizedHar) SearchByMethod(method HTTPMethod) []OptimizedEntries {
	var results []OptimizedEntries

	for _, entry := range oh.Log.Entries {
		if entry.Request.Method == method {
			results = append(results, entry)
		}
	}

	return results
}

// SearchByStatusCode 在优化的HAR中按状态码搜索
func (oh *OptimizedHar) SearchByStatusCode(statusCode int) []OptimizedEntries {
	var results []OptimizedEntries

	for _, entry := range oh.Log.Entries {
		if entry.Response.Status == statusCode {
			results = append(results, entry)
		}
	}

	return results
}

// OptimizedTimings 表示内存优化的计时结构
type OptimizedTimings struct {
	Blocked         *float64 // 使用指针允许nil值
	DNS             *float64 // 使用指针允许nil值
	Connect         *float64 // 使用指针允许nil值
	Send            *float64 // 使用指针允许nil值
	Wait            *float64 // 使用指针允许nil值
	Receive         *float64 // 使用指针允许nil值
	Ssl             *float64 // 使用指针允许nil值
	BlockedQueueing *float64 // 使用指针允许nil值
	BlockedProxy    *float64 // 使用指针允许nil值
}
